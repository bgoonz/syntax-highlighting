hljs.registerLanguage(
  "ruby",
  (() => {
    "use strict";
    return (e) => {
      const n =
        "[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?";

      const a = {
        keyword:
          "and then defined module in return redo if BEGIN retry end for self when next until do begin unless END rescue else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor",
        literal: "true false nil",
      };

      const i = { className: "doctag", begin: "@[A-Za-z]+" };

      const s = {
        begin: "#<",
        end: ">",
      };

      const r = [
        e.COMMENT("#", "$", { contains: [i] }),
        e.COMMENT("^\\=begin", "^\\=end", { contains: [i], relevance: 10 }),
        e.COMMENT("^__END__", "\\n$"),
      ];

      const b = { className: "subst", begin: "#\\{", end: "}", keywords: a };

      const t = {
        className: "string",
        contains: [e.BACKSLASH_ESCAPE, b],
        variants: [
          {
            begin: /'/,
            end: /'/,
          },
          { begin: /"/, end: /"/ },
          { begin: /`/, end: /`/ },
          {
            begin: "%[qQwWx]?\\(",
            end: "\\)",
          },
          { begin: "%[qQwWx]?\\[", end: "\\]" },
          {
            begin: "%[qQwWx]?{",
            end: "}",
          },
          { begin: "%[qQwWx]?<", end: ">" },
          { begin: "%[qQwWx]?/", end: "/" },
          { begin: "%[qQwWx]?%", end: "%" },
          { begin: "%[qQwWx]?-", end: "-" },
          {
            begin: "%[qQwWx]?\\|",
            end: "\\|",
          },
          {
            begin:
              /\B\?(\\\d{1,3}|\\x[A-Fa-f0-9]{1,2}|\\u[A-Fa-f0-9]{4}|\\?\S)\b/,
          },
          {
            begin: /<<[-~]?'?(\w+)(?:.|\n)*?\n\s*\1\b/,
            returnBegin: !0,
            contains: [
              {
                begin: /<<[-~]?'?/,
              },
              e.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [e.BACKSLASH_ESCAPE, b],
              }),
            ],
          },
        ],
      };

      const c = "[0-9](_?[0-9])*";

      const d = {
        className: "number",
        relevance: 0,
        variants: [
          {
            begin: `\\b([1-9](_?[0-9])*|0)(\\.(${c}))?([eE][+-]?(${c})|r)?i?\\b`,
          },
          {
            begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b",
          },
          { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
          {
            begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b",
          },
          {
            begin: "\\b0(_?[0-7])+r?i?\\b",
          },
        ],
      };

      const g = {
        className: "params",
        begin: "\\(",
        end: "\\)",
        endsParent: !0,
        keywords: a,
      };

      const l = [
        t,
        s,
        {
          className: "class",
          beginKeywords: "class module",
          end: "$|;",
          illegal: /=/,
          contains: [
            e.inherit(e.TITLE_MODE, {
              begin: "[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?",
            }),
            {
              begin: "<\\s*",
              contains: [{ begin: `(${e.IDENT_RE}::)?${e.IDENT_RE}` }],
            },
          ].concat(r),
        },
        {
          className: "function",
          beginKeywords: "def",
          end: "$|;",
          contains: [e.inherit(e.TITLE_MODE, { begin: n }), g].concat(r),
        },
        { begin: `${e.IDENT_RE}::` },
        {
          className: "symbol",
          begin: `${e.UNDERSCORE_IDENT_RE}(\\!|\\?)?:`,
          relevance: 0,
        },
        {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [t, { begin: n }],
          relevance: 0,
        },
        d,
        {
          begin: "(\\$\\W)|((\\$|\\@\\@?)(\\w+))",
        },
        { className: "params", begin: /\|/, end: /\|/, keywords: a },
        {
          begin: `(${e.RE_STARTERS_RE}|unless)\\s*`,
          keywords: "unless",
          contains: [
            s,
            {
              className: "regexp",
              contains: [e.BACKSLASH_ESCAPE, b],
              illegal: /\n/,
              variants: [
                { begin: "/", end: "/[a-z]*" },
                { begin: "%r{", end: "}[a-z]*" },
                { begin: "%r\\(", end: "\\)[a-z]*" },
                { begin: "%r!", end: "![a-z]*" },
                { begin: "%r\\[", end: "\\][a-z]*" },
              ],
            },
          ].concat(r),
          relevance: 0,
        },
      ].concat(r);

      (b.contains = l), (g.contains = l);
      const o = [
        {
          begin: /^\s*=>/,
          starts: { end: "$", contains: l },
        },
        {
          className: "meta",
          begin:
            "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+>|(\\w+-)?\\d+\\.\\d+\\.\\d(p\\d+)?[^>]+>)",
          starts: { end: "$", contains: l },
        },
      ];
      return {
        name: "Ruby",
        aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
        keywords: a,
        illegal: /\/\*/,
        contains: r.concat(o).concat(l),
      };
    };
  })()
);
