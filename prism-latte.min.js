!(({languages, hooks}) => {
  languages.latte = {
    comment: /^\{\*[\s\S]*/,
    ld: {
      pattern: /^\{(?:[=_]|\/?(?!\d|\w+\()\w+)?/,
      inside: {
        punctuation: /^\{\/?/,
        tag: { pattern: /.+/, alias: "important" },
      },
    },
    rd: { pattern: /\}$/, inside: { punctuation: /.+/ } },
    php: {
      pattern: /\S(?:[\s\S]*\S)?/,
      alias: "language-php",
      inside: languages.php,
    },
  };
  const e = languages.extend("markup", {});
  languages.insertBefore(
    "inside",
    "attr-value",
    {
      "n-attr": {
        pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
        inside: {
          "attr-name": { pattern: /^[^\s=]+/, alias: "important" },
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              punctuation: [
                /^=/,
                { pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
              ],
              php: { pattern: /\S(?:[\s\S]*\S)?/, inside: languages.php },
            },
          },
        },
      },
    },
    e.tag
  ),
    hooks.add("before-tokenize", a => {
      if ("latte" === a.language) {
        languages["markup-templating"].buildPlaceholders(
          a,
          "latte",
          /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g
        ),
          (a.grammar = e);
      }
    }),
    hooks.add("after-tokenize", a => {
      languages["markup-templating"].tokenizePlaceholders(a, "latte");
    });
})(Prism);
