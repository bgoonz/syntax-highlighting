!(({ util, languages, Token, hooks }) => {
  const t = util.clone(languages.javascript);
  let e = "(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})";
  function n(t, n) {
    return (
      (t = t
        .replace(/<S>/g, () => {
          return "(?:\\s|//.*(?!.)|/\\*(?:[^*]|\\*(?!/))\\*/)";
        })
        .replace(/<BRACES>/g, () => {
          return "(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})";
        })
        .replace(/<SPREAD>/g, () => {
          return e;
        })),
      RegExp(t, n)
    );
  }
  (e = n(e).source),
    (languages.jsx = languages.extend("markup", t)),
    (languages.jsx.tag.pattern = n(
      "</?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[^]|[^\\\\\"])*\"|'(?:\\\\[^]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*/?)?>"
    )),
    (languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/i),
    (languages.jsx.tag.inside["attr-value"].pattern =
      /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/i),
    (languages.jsx.tag.inside.tag.inside["class-name"] =
      /^[A-Z]\w*(?:\.[A-Z]\w*)*$/),
    (languages.jsx.tag.inside.comment = t.comment),
    languages.insertBefore(
      "inside",
      "attr-name",
      { spread: { pattern: n("<SPREAD>"), inside: languages.jsx } },
      languages.jsx.tag
    ),
    languages.insertBefore(
      "inside",
      "special-attr",
      {
        script: {
          pattern: n("=<BRACES>"),
          inside: {
            "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" },
            rest: languages.jsx,
          },
          alias: "language-javascript",
        },
      },
      languages.jsx.tag
    );

  const o = (t) => {
    return t
      ? "string" == typeof t
        ? t
        : "string" == typeof t.content
        ? t.content
        : t.content.map(o).join("")
      : "";
  };

  const r = (t) => {
    for (let n = [], e = 0; e < t.length; e++) {
      const a = t[e];
      let s = !1;
      if (
        ("string" != typeof a &&
          ("tag" === a.type && a.content[0] && "tag" === a.content[0].type
            ? "</" === a.content[0].content[0].content
              ? 0 < n.length &&
                n[n.length - 1].tagName === o(a.content[0].content[1]) &&
                n.pop()
              : "/>" === a.content[a.content.length - 1].content ||
                n.push({
                  tagName: o(a.content[0].content[1]),
                  openedBraces: 0,
                })
            : 0 < n.length && "punctuation" === a.type && "{" === a.content
            ? n[n.length - 1].openedBraces++
            : 0 < n.length &&
              0 < n[n.length - 1].openedBraces &&
              "punctuation" === a.type &&
              "}" === a.content
            ? n[n.length - 1].openedBraces--
            : (s = !0)),
        (s || "string" == typeof a) &&
          0 < n.length &&
          0 === n[n.length - 1].openedBraces)
      ) {
        let g = o(a);
        e < t.length - 1 &&
          ("string" == typeof t[e + 1] || "plain-text" === t[e + 1].type) &&
          ((g += o(t[e + 1])), t.splice(e + 1, 1)),
          0 < e &&
            ("string" == typeof t[e - 1] || "plain-text" === t[e - 1].type) &&
            ((g = o(t[e - 1]) + g), t.splice(e - 1, 1), e--),
          (t[e] = new Token("plain-text", g, null, g));
      }
      a.content && "string" != typeof a.content && r(a.content);
    }
  };

  hooks.add("after-tokenize", ({ language, tokens }) => {
    ("jsx" !== language && "tsx" !== language) || r(tokens);
  });
})(Prism);
