!(({languages, hooks}) => {
  (languages.smarty = {
    comment: /\{\*[\s\S]*?\*\}/,
    delimiter: { pattern: /^\{|\}$/i, alias: "punctuation" },
    string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
    variable: [
      /\$(?!\d)\w+/,
      /#(?!\d)\w+#/,
      { pattern: /(\.|->)(?!\d)\w+/, lookbehind: !0 },
      { pattern: /(\[)(?!\d)\w+(?=\])/, lookbehind: !0 },
    ],
    function: [
      { pattern: /(\|\s*)@?(?!\d)\w+/, lookbehind: !0 },
      /^\/?(?!\d)\w+/,
      /(?!\d)\w+(?=\()/,
    ],
    "attr-name": {
      pattern: /\w+\s*=\s*(?:(?!\d)\w+)?/,
      inside: {
        variable: { pattern: /(=\s*)(?!\d)\w+/, lookbehind: !0 },
        operator: /=/,
      },
    },
    punctuation: [/[\[\]().,:`]|->/],
    operator: [
      /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
      /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
      /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/,
    ],
    keyword: /\b(?:false|no|off|on|true|yes)\b/,
  }),
    hooks.add("before-tokenize", e => {
      let t = !1;
      languages["markup-templating"].buildPlaceholders(
        e,
        "smarty",
        /\{\*[\s\S]*?\*\}|\{[\s\S]+?\}/g,
        e => {
          return (
            "{/literal}" === e && (t = !1),
            !t && ("{literal}" === e && (t = !0), !0)
          );
        }
      );
    }),
    hooks.add("after-tokenize", e => {
      languages["markup-templating"].tokenizePlaceholders(e, "smarty");
    });
})(Prism);
