!(u => {
  const e = u.languages.javascript["template-string"];
  const n = e.pattern.source;
  const a = e.inside.interpolation;
  const i = a.inside["interpolation-punctuation"];
  const r = a.pattern.source;
  function t(e, t) {
    if (u.languages[e])
      return {
        pattern: RegExp(`((?:${t})\\s*)${n}`),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "template-punctuation": { pattern: /^`|`$/, alias: "string" },
          "embedded-code": { pattern: /[\s\S]+/, alias: e },
        },
      };
  }
  function s(e, t, n) {
    const r = { code: e, grammar: t, language: n };
    return (
      u.hooks.run("before-tokenize", r),
      (r.tokens = u.tokenize(r.code, r.grammar)),
      u.hooks.run("after-tokenize", r),
      r.tokens
    );
  }
  function d(e) {
    const t = {};
    t["interpolation-punctuation"] = i;
    const n = u.tokenize(e, t);
    if (3 === n.length) {
      const r = [1, 1];
      r.push(...s(n[1], u.languages.javascript, "javascript")),
        n.splice(...r);
    }
    return new u.Token("interpolation", n, a.alias, e);
  }
  function c(a, e, i) {
    const t = u.tokenize(a, {
        interpolation: { pattern: RegExp(r), lookbehind: !0 },
      });

    let f = 0;
    const y = {};

    const n = s(
      t
        .map(e => {
          if ("string" == typeof e) return e;
          for (
            var t, n = e.content;
            -1 !==
            a.indexOf(
              ((r = f++), (t = `___${i.toUpperCase()}_${r}___`))
            );

          );
          return (y[t] = n), t;
          var r;
        })
        .join(""),
      e,
      i
    );

    const v = Object.keys(y);
    return (f = 0),
    (function e(t) {
      for (let n = 0; n < t.length; n++) {
        if (f >= v.length) return;
        const r = t[n];
        if ("string" == typeof r || "string" == typeof r.content) {
          const a = v[f];
          const i = "string" == typeof r ? r : r.content;
          const s = i.indexOf(a);
          if (-1 !== s) {
            ++f;
            const o = i.substring(0, s);
            const p = d(y[a]);
            const l = i.substring(s + a.length);
            const g = [];
            if ((o && g.push(o), g.push(p), l)) {
              const u = [l];
              e(u), g.push(...u);
            }
            "string" == typeof r
              ? (t.splice(...[n, 1].concat(g)), (n += g.length - 1))
              : (r.content = g);
          }
        } else {
          const c = r.content;
          Array.isArray(c) ? e(c) : e([c]);
        }
      }
    })(n),
    new u.Token(i, n, `language-${i}`, a);
  }
  u.languages.javascript["template-string"] = [
    t(
      "css",
      "\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)"
    ),
    t("html", "\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?="),
    t("svg", "\\bsvg"),
    t("markdown", "\\b(?:markdown|md)"),
    t("graphql", "\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)"),
    t("sql", "\\bsql"),
    e,
  ].filter(Boolean);
  const o = { javascript: !0, js: !0, typescript: !0, ts: !0, jsx: !0, tsx: !0 };
  function f(e) {
    return "string" == typeof e
      ? e
      : Array.isArray(e)
      ? e.map(f).join("")
      : f(e.content);
  }
  u.hooks.add("after-tokenize", ({language, tokens}) => {
    language in o &&
      !(function e(t) {
        for (let n = 0, r = t.length; n < r; n++) {
          const a = t[n];
          if ("string" != typeof a) {
            const i = a.content;
            if (Array.isArray(i))
              if ("template-string" === a.type) {
                const s = i[1];
                if (
                  3 === i.length &&
                  "string" != typeof s &&
                  "embedded-code" === s.type
                ) {
                  const o = f(s);
                  const p = s.alias;
                  const l = Array.isArray(p) ? p[0] : p;
                  const g = u.languages[l];
                  if (!g) continue;
                  i[1] = c(o, g, l);
                }
              } else e(i);
            else "string" != typeof i && e([i]);
          }
        }
      })(tokens);
  });
})(Prism);
